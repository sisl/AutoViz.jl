var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"List of functions and datastructure available in AutoViz","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [AutoViz]","category":"page"},{"location":"api/#AutoViz.ArrowCar","page":"API","title":"AutoViz.ArrowCar","text":"A basic drawable rectangle representing a car. An arrow indicates the heading direction of the car.\n\nArrowCar{A<:AbstractArray{Float64}, C<:Colorant} <: Renderable\nArrowCar(pos::AbstractArray, angle::Float64=0.0; length = 4.8, width = 1.8,  color=colortheme[\"COLOR_CAR_OTHER\"], text=\"\", id=0)\nArrowCar(x::Real, y::Real, angle::Float64=0.0; length = 4.8, width = 1.8,  color=colortheme[\"COLOR_CAR_OTHER\"], text=\"\", id=0)\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.BlinkerOverlay","page":"API","title":"AutoViz.BlinkerOverlay","text":"BlinkerOverlay\n\nDisplays a circle on one of the top corner of a vehicle to symbolize a blinker.  fields: \n\non: turn the blinker on\nright: blinker on the top right corner, if false, blinker on the left \nveh: the vehicle for which to display the blinker \ncolor: the color of the blinker\nsize: the size of the blinker \n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.Camera","page":"API","title":"AutoViz.Camera","text":"Camera abstract type\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.CameraState","page":"API","title":"AutoViz.CameraState","text":"CameraState(;\n    position::VecE2      = VecE2(0.,0.),\n    zoom::Real           = 1.,\n    rotation::Real       = 0.,\n    canvas_width::Int64  = DEFAULT_CANVAS_WIDTH\n    canvas_height::Int64 = DEFAULT_CANVAS_HEIGHT\n)\n\nRepresentation of the internal camera state.\n\nposition::VecE2: the (x,y) position of the camera in [metre].   The x-direction is measured to the east, y direction to the north.\nzoom::Real: the zoom level of the camera, expressed in [pixels / metre]\nrotation::Real: the rotation angle of the camera in [radian]\ncanvas_width::Int64: the canvas width in [pixel]\ncanvas_height::Int64: the canvas width in [pixel]\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.CarFollowingStatsOverlay","page":"API","title":"AutoViz.CarFollowingStatsOverlay","text":"CarFollowingStatsOverlay\n\nDisplays statistics about the front neighbor of the car of id target_id.\n\nConstructor\n\nCarFollowingStatsOverlay(;target_id, verbosity=1, color=colorant\"white\", font_size=10)\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.ComposedCamera","page":"API","title":"AutoViz.ComposedCamera","text":"ComposedCamera <: Camera\n\nComposition of several cameras. The update_camera actions of the individual cameras are applied in the order in which they are saved in the cameras array. States of individual cameras are ignored, the state of the composed camera is the one that will be used for rendering.\n\nExample Usage\n\ncam = ComposedCamera(cameras=[SceneFollowCamera(), ZoomingCamera()])\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.EntityRectangle","page":"API","title":"AutoViz.EntityRectangle","text":"A drawable rectangle with rounded corners representing an entity.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.FancyCar","page":"API","title":"AutoViz.FancyCar","text":"A drawable 'fancy' svg image of a race car. The car is placed at the position of entity and the width and length are scaled accordingly. The color of the car can be specified using the color keyword.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.FancyPedestrian","page":"API","title":"AutoViz.FancyPedestrian","text":"A drawable 'fancy' svg image of a pedestrian. The pedestrian is placed at the position of entity and the width and length of the original image are scaled accordingly. The color of the pedestrian can be specified using the color keyword.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.HistogramOverlay","page":"API","title":"AutoViz.HistogramOverlay","text":"HistogramOverlay\n\nDisplay a bar at the specified position pos, the bar is of size width, height and is filled up to a given proportion of its height.  The fill proportion is set using val, it should be a number between 0 and 1. If it is 0, the bar is not filled, if it is 1 it is filled to the top.\n\nFields\n\npos::VecE2{Float64} = VecE2(0.,0.)\ncoordinate_system::Symbol = :scene\nlabel::String = \"histogram\"\nval::Float64 = 0.5 should be between 0 and 1\nwidth::Float64 = 2.\nheight::Float64 = 5.\nfill_color::Colorant = colorant\"blue\"\nline_color::Colorant = colorant\"white\"\nfont_size::Int64 = 15 # [pix]\nlabel_pos::VecSE2{Float64} = pos + VecSE2(0., -height/2) position of the label\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.IDOverlay","page":"API","title":"AutoViz.IDOverlay","text":"IDOverlay\n\nDisplay the ID on top of each entity in a scene. The text can be customized with the color::Colorant (default=white) and font_size::Int64 (default=15) keywords. The position of the ID can be adjusted using x_off::Float64 and y_off::Float64 (in camera coordinates).\n\nFields\n\ncolor::Colorant = colorant\"white\"\nfont_size::Int = 15\nx_off::Float64 = 0.\ny_off::Float64 = 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.NeighborsOverlay","page":"API","title":"AutoViz.NeighborsOverlay","text":"NeighborsOverlay\n\nDraws a line between a vehicle and its neighbors. The neighbors are linked with different colors depending on their lanes. This overlay needs to be wrapped as a RenderableOverlay which needs a scene and a roadway to perform the calculation of the neighbors.\n\nFields\n\ntarget_id::Int\ncolor_L::Colorant = colorant\"blue\"\ncolor_M::Colorant = colorant\"green\ncolor_R::Colorant = colorant\"red\"\nline_width::Float64 = 0.5 \ntextparams::TextParams = TextParams()\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.Overwash","page":"API","title":"AutoViz.Overwash","text":"Overwash\n\noverlay that renders a plain color on the whole canvas.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.RenderModel","page":"API","title":"AutoViz.RenderModel","text":"RenderModel\n\nModel to keep track of rendering instructions and background color.\n\ninstruction_set::AbstractVector{Tuple}: set of render instructions (function, array of inputs sans ctx, coordinate_system)\nbackground_color::RGB: background color\n\nFields\n\ninstruction_set  :: AbstractVector{Tuple} = Array{Tuple}(undef, 0)\nbackground_color :: RGB = colortheme[\"background\"]\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.RenderableOverlay","page":"API","title":"AutoViz.RenderableOverlay","text":"RenderableOverlay\n\nDecorator which allows to use SceneOverlay objects together with the method     render([Renderables])\n\nThis is required primarily for allowing backward compatibility with overlays that use the old rendering interface.\n\nusage:  RenderableOverlay(o::Overlay, scene::Frame, roadway::Roadway)\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.SceneFollowCamera","page":"API","title":"AutoViz.SceneFollowCamera","text":"SceneFollowCamera\n\nCamera centered over all vehicles.\n\nBy default, the scene is tracked in x and y direction and the zoom level  is adapted to fit all vehicles in the scene. Tracking in either direction can be disabled by setting the x or y keys to a desired value. The zoom level can be fixed by passing a value to zoom. The value of padding specifies the width of the additional border around the zoomed-in area.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.StaticCamera","page":"API","title":"AutoViz.StaticCamera","text":"StaticCamera <: Camera\n\nFix the position and the zoom as specified in the constructor.\n\nConstructor\n\nStaticCamera(position::VecE2=(0,0), zoom::Real=4)\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.TargetFollowCamera","page":"API","title":"AutoViz.TargetFollowCamera","text":"TargetFollowCamera <: Camera\n\nCamera which follows the vehicle with ID target_id. By default, the target vehicle is tracked in x and y direction. Tracking in either direction can be disabled by setting the  x or y keys to a desired value.\n\nConstructor\n\nTargetFollowCamera(target_id; x=NaN, y=NaN, kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.TextOverlay","page":"API","title":"AutoViz.TextOverlay","text":"TextOverlay\n\nDisplays some text at the desired location.  The coordinates and size units are in pixels by default.  The option coordinate_system allows to use different units.\n\nFields\n\ntext::Vector{String}\ncolor::Colorant = colorant\"white\"\nfont_size::Int = 10\npos::VecE2 = VecE2(10, font_size)\nline_spacing::Float64 = 1.5 multiple of font_size\ncoordinate_system::Symbol=:camera_pixels\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.VelocityArrow","page":"API","title":"AutoViz.VelocityArrow","text":"A drawable arrow representing the current velocity vector of an entity. The arrow points to the location where the vehicle will be one second in the future (assuming linear motion).\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.ZoomingCamera","page":"API","title":"AutoViz.ZoomingCamera","text":"ZoomingCamera <: Camera\n\nCamera which gradually changes the zoom level of the scene to zoom_target with step size dz.\n\n\n\n\n\n","category":"type"},{"location":"api/#AutoViz.add_instruction!-Tuple{RenderModel,Function,Tuple}","page":"API","title":"AutoViz.add_instruction!","text":"Add an instruction to the rendermodel\n\nINPUT:     rendermodel   - the RenderModel we are adding the instruction to     f             - the function to be called, the first argument must be a CairoContext     args          - tuple of input arguments to f, skipping the CairoContext     coordinatesystem - in which coordinate system are the coordinates given (one of :scene, :camerapixels, :camerarelative)       :scene - coordinates are physical coordinates in the world frame in unit [meters]       `:camerapixels- coordinates are in pixels and relative to the rectangle selected by the camera in unit [pixels]:camera_relative` - coordinates are in percentages in the range 0 to 1 of the rectangle selected by the camera\n\nex: addinstruction!(rendermodel, rendertext, (\"hello world\", 10, 20, 15, [1.0,1.0,1.0]))\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.add_renderable!-Tuple{RenderModel,String}","page":"API","title":"AutoViz.add_renderable!","text":"Render function for text\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.add_renderable!-Union{Tuple{E}, Tuple{RenderModel,E}, Tuple{RenderModel,E,Union{Nothing, Colorant}}} where E<:Records.Entity","page":"API","title":"AutoViz.add_renderable!","text":"Helper function for directly rendering entities, takes care of wrapping them in renderable objects\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.add_renderable!-Union{Tuple{E}, Tuple{RenderModel,Frame{E}}} where E<:Records.Entity","page":"API","title":"AutoViz.add_renderable!","text":"Helper function for directly rendering frames of renderable entities\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.isrenderable","page":"API","title":"AutoViz.isrenderable","text":"Return true if an object or type is directly renderable, false otherwise.\n\nNew types should implement the isrenderable(t::Type{NewType}) method.\n\n\n\n\n\n","category":"function"},{"location":"api/#AutoViz.render-Tuple{AbstractArray{T,1} where T}","page":"API","title":"AutoViz.render","text":"render(\n    renderables::AbstractVector;\n    camera::Union{Nothing, Camera} = nothing,\n    canvas_width::Int64 = (camera === nothing ? DEFAULT_CANVAS_WIDTH : canvas_width(camera)),\n    canvas_height::Int64 = (camera === nothing ? DEFAULT_CANVAS_HEIGHT : canvas_height(camera)),\n    surface::CairoSurface = CairoSVGSurface(IOBuffer(), canvas_width, canvas_height)\n)\n\nDraw all renderables to a surface of dimensions canvas_width x canvas_height. All renderables must implement the add_renderable! function which adds rendering instructions to the render model.\n\nThe provided camera should be updated using the  update_camera!() function before calling render. If no camera is provided, the render function will default to fitting all renderable objects to the canvas.\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.set_color_theme-Tuple{Any}","page":"API","title":"AutoViz.set_color_theme","text":"set_color_theme(colortheme)\n\nChange the color theme of the package\n\n\n\n\n\n","category":"method"},{"location":"api/#AutoViz.camera_fit_to_content","page":"API","title":"AutoViz.camera_fit_to_content","text":"camera_fit_to_content(rendermodel::RenderModel, ctx::CairoContext, canvas_width::Integer = DEFAULT_CANVAS_WIDTH, canvas_height::Integer = DEFAULT_CANVAS_HEIGHT; percent_border::Real = 0.0)\n\nHelper function that determines camera parameters such that all rendered content fits on the canvas.\n\n\n\n\n\n","category":"function"},{"location":"api/#AutoViz.id_to_color-Tuple{Any}","page":"API","title":"AutoViz.id_to_color","text":"id_to_color(id)\n\nRandom color based on hash code of the ID see https://stackoverflow.com/questions/11120840/hash-string-into-rgb-color\n\n\n\n\n\n","category":"method"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"EditURL = \"https://github.com/sisl/AutoViz.jl/blob/master/docs/lit/tutorials/cameras.jl\"","category":"page"},{"location":"tutorials/cameras/#Cameras-1","page":"Cameras","title":"Cameras","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: )","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"In this section, we will showcase the cameras that are supported by AutoViz.jl.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"All cameras make use of the CameraState object to represent the internal camera state.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"CameraState","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"The following camera types are supported by AutoViz: StaticCamera, TargetFollowCamera, SceneFollowCamera, ZoomingCamera, ComposedCamera. The keyword arguments accepted by the CameraState object can also be passed to the constructors of these cameras, and they will be forwarded to the internal camera state. Now, we will show how the different cameras behave based on the simple stadium example.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"First, we prepare a sequence of scenes visualize","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\n\nnlanes = 4\nnveh = 5\nnticks = 100\ntimestep = 0.1\n\nroadway = gen_stadium_roadway(nlanes)\n\nscene = Frame([Entity(VehicleState(\n    Frenet(roadway[LaneTag(1,rand(1:nlanes))], 10.0*i), roadway, 4.0 + 2.0rand()\n), VehicleDef(), i) for i in 1:nveh])\n\nmodels = Dict((\n    i => LatLonSeparableDriver(ProportionalLaneTracker(), IntelligentDriverModel())\n    for i in 1:nveh\n))\nset_desired_speed!.(values(models), 8.0 .+ 4.0rand(nveh))\n\n\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"The following helper function takes care of generating an animation from a sequence of scenes, using a given camera. Note that for camera=nothing, the render function attempts to fit all the renderable objects on the canvas.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"using Reel\n\nfunction animate(roadway, scenes, camera=nothing)\n    animation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n        i = Int(floor(t/dt)) + 1\n        update_camera!(camera, scenes[i])\n        renderables = [\n            roadway, scenes[i],\n            RenderableOverlay(IDOverlay(x_off=-2, y_off=1), scenes[i], roadway),\n        ]\n        render(renderables, camera=camera)\n    end\n    return animation\nend\nnothing # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"The call to update_camera!(camera, scenes[i]) is important as it allows the internal camera state to be updated based on the positions of the vehicles.","category":"page"},{"location":"tutorials/cameras/#Default-camera:-fit-to-content-1","page":"Cameras","title":"Default camera: fit to content","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"The default camera uses the render instructions that are stored inside the RenderModel in order to compute a bounding box which holds all renderable objects.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes);\nwrite(\"stadium_cam_default.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: default camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Note that some renderable objects (such as custom objects) may not be considered by the default fit to content camera when the bounding box is computed. Therefore, they may be cut off.","category":"page"},{"location":"tutorials/cameras/#Static-Camera-1","page":"Cameras","title":"Static Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"A static camera maintains its position, zoom and rotation. It is the only camera that doesn't change its state when calling update_camera!().","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, StaticCamera(zoom=5.))\nwrite(\"stadium_cam_static_default.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: static default camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"We can pass in zoom, position and rotation parameters in order to change the camera state.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(\n    roadway, scenes,\n    StaticCamera(position=VecE2(20.,10.), rotation=.2, zoom=8.)\n)\nwrite(\"stadium_cam_static_custom.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: static custom camera)","category":"page"},{"location":"tutorials/cameras/#Target-Follow-Camera-1","page":"Cameras","title":"Target Follow Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"In many applications, we are interested in tracking one particular vehicle. To do this, we can use a TargetFollowCamera which follows a vehicle with a given ID. Let's follow the vehicle with ID 3:","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, TargetFollowCamera(3, zoom=5.))\nwrite(\"stadium_cam_target.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: target follow camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Sometimes, it is desireable fix the x or y position of the camera. For example, we can use the TargetFollowCamera to track a vehicle horizontally (in x direction), while keeping the vertical position (y direction) fixed. To do this, we simply provide a fixed value for the corresponding keyword argument y.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, TargetFollowCamera(3, zoom=10., y=40.))\nwrite(\"stadium_cam_target_y.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: target follow camera, fixed y)","category":"page"},{"location":"tutorials/cameras/#Scene-Follow-Camera-1","page":"Cameras","title":"Scene Follow Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"In contrast to the TargetFollowCamera, the SceneFollowCamera tracks the center of mass of all the vehicles in a scene. The padding parameter specifies how man metres of padding there should be around the vehicles in the scene","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, SceneFollowCamera(padding=4.))\nwrite(\"stadium_cam_scene.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: scene follow camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"If we desire to follow the scene, but fix the zoom level, we can do so by passing in the corresponding keyword argument zoom.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, SceneFollowCamera(zoom=20.))\nwrite(\"stadium_cam_scene_zoom.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: scene follow camera)","category":"page"},{"location":"tutorials/cameras/#Zooming-Camera-1","page":"Cameras","title":"Zooming Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"The zooming camera changes its zoom level by an increment dz anytime the update_camera!() function is called, until a zoom level of zoom_target is reached.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, ZoomingCamera(zoom_target=20., dz=0.4, zoom=2.))\nwrite(\"stadium_cam_zooming.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: zooming camera)","category":"page"},{"location":"tutorials/cameras/#Composed-Camera-1","page":"Cameras","title":"Composed Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Finally, the ComposedCamera can be used to combine different camera behaviors. For example, one can use the TargetFollowCamera together with the ZoomingCamera in order to follow a vehicle and zoom in on it. The constructor of the CompostedCamera takes an array of cameras which are applied in the same sequence as they are provided in the array.","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, ComposedCamera([\n    TargetFollowCamera(3),\n    ZoomingCamera(zoom_target=25., dz=0.4, zoom=1.),\n]))\nwrite(\"stadium_cam_composed.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: composed camera)","category":"page"},{"location":"tutorials/cameras/#Custom-Camera-1","page":"Cameras","title":"Custom Camera","text":"","category":"section"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Finally, we will show how to build a custom camera. We will build a camera whose angle is always aligned with the axis of the target vehicle with ID target_id","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"mutable struct TargetRotateCamera{I} <: Camera\n    state::CameraState\n    target_id::I\nend\nTargetRotateCamera(target_id; kwargs...) = TargetRotateCamera(CameraState(;kwargs...), target_id)\nnothing # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"In the update_camera!() function, we need to set the camera rotation to be the same as the vehicle yaw angle","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"function AutoViz.update_camera!(camera::TargetRotateCamera{I}, scene::Frame{E}) where {I,E<:Entity}\n    target = get_by_id(scene, camera.target_id)\n    yaw = posg(target.state)[3]\n    set_camera!(camera.state, rotation=-yaw)\n    return camera.state\nend\nnothing # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Finally, we can use our custom camera just like the other cameras","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, TargetRotateCamera(3, zoom=5.))\nwrite(\"stadium_cam_custom.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: custom camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"Also, we can combine the camera with other cameras to our liking","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"animation = animate(roadway, scenes, ComposedCamera([\n    TargetFollowCamera(3),\n    TargetRotateCamera(3),\n    ZoomingCamera(zoom_target=25., dz=0.4, zoom=1.),\n]))\nwrite(\"stadium_cam_composed_custom.gif\", animation) # hide","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"(Image: composed camera)","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"","category":"page"},{"location":"tutorials/cameras/#","page":"Cameras","title":"Cameras","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"EditURL = \"https://github.com/sisl/AutoViz.jl/blob/master/docs/lit/tutorials/overlays.jl\"","category":"page"},{"location":"tutorials/overlays/#Overlays-1","page":"Overlays","title":"Overlays","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: )","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Overlays are useful to display additional information on top of a given driving scene. For example, they can be used to display the ID of the vehicle, their speed, or other useful information. The underlying type from which all overlays should inherit is SceneOverlay.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"More generally, renderable objects that are passed to the render function are rendered in the order they are passed in. For example, if we pass a collection consisting of a roadway and a scene, the roadway is rendered first, and the scene is rendered on top of the roadway.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"This behavior leaves the possibility to create overlays as well as \"underlays\" that may be drawn under the vehicles.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"In this tutorial, we will use the same stadium scenario as shown in the camera example.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\nAutoViz.set_render_mode(:fancy)\n\nnlanes = 2\nnveh = 8\nnticks = 100\ntimestep = 0.1\n\nroadway = gen_stadium_roadway(nlanes)\n\nscene = Frame([\n    Entity(\n        VehicleState(\n            Frenet(roadway[LaneTag(1,rand(1:nlanes))], 10.0*i),  # position\n            roadway, 4.0 + 2.0rand()  # speed\n        ),\n        VehicleDef(), i\n    ) for i in 1:nveh\n])\n\nmodels = Dict((\n    i => LatLonSeparableDriver(ProportionalLaneTracker(), IntelligentDriverModel())\n    for i in 1:nveh\n))\nset_desired_speed!.(values(models), 8.0 .+ 4.0rand(nveh))\n\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"The following code will help us to animate the simulation using Reel","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"using Reel\n\nfunction animate(roadway, scenes, overlays, camera=TargetFollowCamera(3, zoom=15.))\n    animation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n        i = Int(floor(t/dt)) + 1\n        update_camera!(camera, scenes[i])\n        renderables = [\n            roadway, scenes[i], overlays[i]...\n        ]\n        render(renderables, camera=camera)\n    end\n    return animation\nend\nnothing # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"The animate function defined above takes an overlays object which holds a list of overlays for every frame in scenes.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"note: Note\nNote on compatibility: The interface for rendering overlays has changed in version 0.8 of AutoViz. In older versions of AutoViz, overlays were rendered by passing in the current scene and roadway explicitly. Since AutoViz 0.8, every renderable object must have the same interface. As a result, an overlay that requires the roadway or scene for rendering, must store those objects as internal variables. RenderableOverlay is an overlay that can be used as a wrapper around older overlays which rely on the scene and roadway objects. Those overlays are marked by the tag [legacy]","category":"page"},{"location":"tutorials/overlays/#IDOverlay-[legacy]-1","page":"Overlays","title":"IDOverlay [legacy]","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Show IDs for all vehicles in the scene","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[RenderableOverlay(\n    IDOverlay(x_off=-2, y_off=1), scene, roadway\n)] for scene in scenes]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_id_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with ID overlay)","category":"page"},{"location":"tutorials/overlays/#CarFollowingStatsOverlay-[legacy]-1","page":"Overlays","title":"CarFollowingStatsOverlay [legacy]","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Diplays info about the front neighbor of a car such as the difference in velocity and the relative distance. Show statistics for vehicle 3:","category":"page"},{"location":"tutorials/overlays/#TODO:-overlay-name-is-not-very-descriptive-1","page":"Overlays","title":"TODO: overlay name is not very descriptive","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[RenderableOverlay(CarFollowingStatsOverlay(\n    target_id=3, font_size=20, color=colorant\"black\"\n), scene, roadway)] for scene in scenes]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_car_stats_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with car stats overlay)","category":"page"},{"location":"tutorials/overlays/#LineToFrontOverlay-[legacy]-1","page":"Overlays","title":"LineToFrontOverlay [legacy]","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Show the line to the front vehicle for vehicle 3","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[RenderableOverlay(\n    LineToFrontOverlay(target_id=3), scene, roadway\n)] for scene in scenes]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_line_front_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with ID overlay)","category":"page"},{"location":"tutorials/overlays/#TextOverlay-1","page":"Overlays","title":"TextOverlay","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"The TextOverlay displays some text at the desired location. By default, the coordinates are in camera pixels.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[TextOverlay(\n    text=[\"Overlays are nice!\", \"frame $(i)/$(length(scenes))\"],\n    font_size=30, pos=VecE2(50.0, 100.0), color=colorant\"black\",\n    coordinate_system=:camera_pixels\n)] for i in 1:length(scenes)]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_text_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with text overlay)","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"setting the coordinate_system keyword to :scene places the text in scene coordinates","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[TextOverlay(\n    text=[\"Scene Coordinates!\"],\n    font_size=10+round(20cos(.01i)),\n    pos=VecE2(2i, 40+round(20*sin(.002i))),\n    color=colorant\"black\", coordinate_system=:scene\n)] for i in 1:length(scenes)]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_moving_text_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with moving text overlay)","category":"page"},{"location":"tutorials/overlays/#HistogramOverlay-1","page":"Overlays","title":"HistogramOverlay","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Display a bar at the specified position pos. The bar has dimensions width and height and is filled up to a given proportion of its height. The fill proportion is set using val, which should be a number between 0 and 1. If it is 0, the bar is not filled, if it is 1 it is filled to the top. The default units are in the camera frame.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"max_speed = 14.0\noverlays = [[HistogramOverlay(\n    pos=VecE2(40.0, 100.0), val=get_by_id(scene, 1).state.v/max_speed, label=\"veh1 speed\",\n    fill_color=colorant\"blue\", line_color=colorant\"black\",\n    font_size=24, width=10, height=50\n)] for scene in scenes]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"stadium_histogram_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with moving text overlay)","category":"page"},{"location":"tutorials/overlays/#NeighborsOverlay-[legacy]-1","page":"Overlays","title":"NeighborsOverlay [legacy]","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Draws a line between a vehicle and its neighbors.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"overlays = [[\n    RenderableOverlay(\n        NeighborsOverlay(target_id=3, textparams=TextParams(color=colorant\"black\")),\n        scene, roadway,\n    )\n] for (i, scene) in enumerate(scenes)]\nanimation = animate(roadway, scenes, overlays)\nwrite(\"neighbors_overlay.gif\", animation) # hide","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: stadium with neighbors overlay)","category":"page"},{"location":"tutorials/overlays/#Custom-Overlays-1","page":"Overlays","title":"Custom Overlays","text":"","category":"section"},{"location":"tutorials/overlays/#Lane-Highlighting-1","page":"Overlays","title":"Lane Highlighting","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"Just like roadways and vehicles, overlays are renderable objects. In order to make a custom overlay type renderable, one needs to implement the add_renderable!(::RenderModel, ::YourOverlay) function. Overlays should inherit from the SceneOverlay type.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"To define an overlay which highlights a lane, let's start by defining a custom type LaneOverlay","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"struct LaneOverlay <: SceneOverlay\n    lane::Lane\n    roadway::Roadway\n    color::Colorant\nend\n\nfunction AutoViz.add_renderable!(rendermodel::RenderModel, overlay::LaneOverlay)\n    add_renderable!(rendermodel, overlay.lane, overlay.roadway, color_asphalt=overlay.color)\n    return rendermodel\nend","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"We can now initiate a LaneOverlay object and pass it to the render function","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"lane_overlay = LaneOverlay(roadway[LaneTag(1,1)], roadway, RGBA(0.0,0.0,1.0,0.5))\ncamera = TargetFollowCamera(3, zoom=15.)\nupdate_camera!(camera, scene)\nsnapshot = render([roadway, lane_overlay, scene], camera=camera)\nwrite(\"stadium_lane_overlay.svg\", snapshot)","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: lane overlay)","category":"page"},{"location":"tutorials/overlays/#Concentric-Rectangle-Overlay-1","page":"Overlays","title":"Concentric Rectangle Overlay","text":"","category":"section"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"In the following, we will show a more advanced example in which direct manipulation of the CairoContext is required. We will create an overlay which draws concentric rectangles around a vehicle with ID target_id","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"struct ConcentricRectOverlay <: SceneOverlay\n    target_id\n    scene::Frame\n    n::Int64\n    color::Colorant\nend","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"We implement a new rendering function for concentric rectangles","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"using Cairo\n\nfunction render_concentric_rects(\n    ctx::CairoContext,\n    n::Int,\n    x::Real, y::Real,\n    w::Real, l::Real,\n    yaw::Real,\n    color::Colorant\n)\n    save(ctx)\n    translate(ctx, x, y)\n    rotate(ctx, yaw)\n\n    for i in 1:n\n        AutoViz.render_round_rect(\n            ctx,\n            0, 0, l+2(i-1), w+2(i-1), 1., (i-.5),\n            RGBA(color.r, color.g, color.b, 1-i/n),\n            true, false,\n        )\n    end\n\n    restore(ctx)\nend","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"The add_renderable function adds the function defined above to the instruction stack of the render model via add_instruction!. A series of common rendering instructions are already implemented as part of the AutoViz.jl framework.","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"function AutoViz.add_renderable!(rendermodel::RenderModel, overlay::ConcentricRectOverlay)\n    veh = get_by_id(overlay.scene, overlay.target_id)\n    x, y, yaw = posg(veh)\n    w, l = AutomotiveDrivingModels.width(veh.def), length(veh.def)\n\n    add_instruction!(\n        rendermodel, render_concentric_rects,\n        (overlay.n, x, y, w, l, yaw, overlay.color)\n    )\n    return rendermodel\nend\n\nconcentric_rect_overlay = ConcentricRectOverlay(3, scene, 5, colorant\"green\")\nsnapshot = render([roadway, concentric_rect_overlay, scene], camera=camera)\nwrite(\"stadium_concentric_rect_overlay.svg\", snapshot)","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"(Image: lane overlay)","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"nothing","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"","category":"page"},{"location":"tutorials/overlays/#","page":"Overlays","title":"Overlays","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"EditURL = \"https://github.com/sisl/AutoViz.jl/blob/master/docs/lit/tutorials/basics.jl\"","category":"page"},{"location":"tutorials/basics/#AutoViz-Basics-1","page":"AutoViz Basics","title":"AutoViz Basics","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: )","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"To run these tutorials, you must be using julia 1.1+ and have AutoViz.jl installed.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"The core function of the AutoViz.jl package is AutoViz.render()","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"render","category":"page"},{"location":"tutorials/basics/#AutoViz.render","page":"AutoViz Basics","title":"AutoViz.render","text":"render(\n    renderables::AbstractVector;\n    camera::Union{Nothing, Camera} = nothing,\n    canvas_width::Int64 = (camera === nothing ? DEFAULT_CANVAS_WIDTH : canvas_width(camera)),\n    canvas_height::Int64 = (camera === nothing ? DEFAULT_CANVAS_HEIGHT : canvas_height(camera)),\n    surface::CairoSurface = CairoSVGSurface(IOBuffer(), canvas_width, canvas_height)\n)\n\nDraw all renderables to a surface of dimensions canvas_width x canvas_height. All renderables must implement the add_renderable! function which adds rendering instructions to the render model.\n\nThe provided camera should be updated using the  update_camera!() function before calling render. If no camera is provided, the render function will default to fitting all renderable objects to the canvas.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"In its simplest form, the render function only takes one argument: an iterable collection of renderable objects, renderables. In order for an object to be renderable, it needs to implement the add_renderable!() function.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"By default, the render() function will do its best to make all the contents of the scene fit to the canvas of dimensions canvas_width x canvas_height. More fine-grained control over camera positioning can be achieved by providing the camera keyword. In case a custom camera is used, it is important to call update_camera!(camera, scene) before rendering.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"The Cairo surface to be used for plotting can be specified using the surface keyword. The render() function applies the rendering instructions to the surface and returns it. In the tutorials, we will denote the returned surface as a snapshot of the scene. Such snapshots can be saved to file using the command","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"write(\"snapshot.svg\", snapshot)","category":"page"},{"location":"tutorials/basics/#Basic-rendering-1","page":"AutoViz Basics","title":"Basic rendering","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"We start our example by rendering an empty roadway","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"using AutomotiveDrivingModels\nusing AutoViz\n\nroadway = gen_straight_roadway(3, 100.0)\n\nsnapshot = render([roadway], canvas_height=120)\nwrite(\"empty_roadway.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: empty roadway)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"We can change the background color and render again","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"AutoViz.colortheme[\"background\"] = colorant\"white\"\nsnapshot = render([roadway], canvas_height=120)\nwrite(\"empty_roadway_whitebg.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: empty roadway)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"Let's add some vehicles to the roadway","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"car_len = 4.8\ncar_width = 1.8\ndef = VehicleDef(AgentClass.CAR, car_len, car_width)\nw = DEFAULT_LANE_WIDTH\nscene = Scene(4)  # allocate a scene for 4 agents","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"add three cars","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"push!.(Ref(scene), [\n    Vehicle(VehicleState(VecSE2(10.0,   w, 0.0), roadway, 4.0 + 2.0randn()), def, 1),\n    Vehicle(VehicleState(VecSE2(40.0, 0.0, 0.0), roadway, 4.0 + 2.0randn()), def, 2),\n    Vehicle(VehicleState(VecSE2(70.0,   w, 0.0), roadway, 4.0 + 2.0randn()), def, 3),\n])","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"add a pedestrian","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"push!(scene, Vehicle(\n    VehicleState(VecSE2(50.0, 2w, -Ï€/2), roadway, 2.0),\n    VehicleDef(AgentClass.PEDESTRIAN, 1., 1.),\n    42\n))\nsnapshot = render([roadway, scene], canvas_height=120)\nwrite(\"roadway_with_cars.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: roadway with cars)","category":"page"},{"location":"tutorials/basics/#Vehicle-Shapes-1","page":"AutoViz Basics","title":"Vehicle Shapes","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"The render function provides some defaults for rendering basic building blocks such as entities or roadways. If the value of AutoViz.rendermode is set to :basic, entities are simply rendered as rectangles with arrows indicating their velocities. This can also be done explicitly via","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"renderables = [\n    roadway,\n    (EntityRectangle(entity=x) for x in scene)...,\n    (VelocityArrow(entity=x) for x in scene)...,\n]\nsnapshot = render(renderables, canvas_height=120)\nwrite(\"roadway_basic_manual.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: roadway basic manual)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"The result remains the same. The velocity arrows point to the location at which the vehicle would be 1 second in the future.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"Setting AutoViz.rendermode to :fancy, the rectangles are replaced by SVG images of cars (or pedestrians).","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"AutoViz.set_render_mode(:fancy)\nsnapshot = render([roadway, scene], canvas_height=120)\nwrite(\"roadway_fancy.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: roadway fancy)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"Which is shorthand for","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"renderables = [\n    roadway, (FancyCar(car=scene[i]) for i in 1:3)..., FancyPedestrian(ped=scene[4])\n]\nsnapshot = render(renderables, canvas_height=120)\nwrite(\"roadway_fancy_manual.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: roadway fancy manual)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"A third visualization mode is available in the form of arrow cars, in which the arrow indicates the heading direction of the car but does not scale with speed.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"renderables = [\n    roadway, (ArrowCar(car=scene[i]) for i in 1:3)..., FancyPedestrian(ped=scene[4])\n]\nsnapshot = render(renderables, canvas_height=120)\nwrite(\"roadway_arrow.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: roadway arrow)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"It is also possible to render single vehicles","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"fancy_car = FancyCar(car=Vehicle(VehicleState(VecSE2(0.,0.), 0.), VehicleDef(), 1))\nsnapshot = render([fancy_car], camera=StaticCamera(zoom=100.))\nwrite(\"fancy_car.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: fancy car)","category":"page"},{"location":"tutorials/basics/#Vehicle-Colors-1","page":"AutoViz Basics","title":"Vehicle Colors","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"By default, the render function generates a random color for each entity based on its ID using the id_to_color() function. However, vehicle colors can also be assigned explicitly:","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"colors = [colorant\"red\", colorant\"blue\", colorant\"green\"]\nrenderables = [\n    roadway,\n    (FancyCar(car=scene[i], color=colors[i]) for i in 1:3)...,\n    FancyPedestrian(ped=scene[4], color=colorant\"yellow\")\n]\nsnapshot = render(renderables, canvas_height=120)\nwrite(\"scene_custom_colors.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: cars with custom colors)","category":"page"},{"location":"tutorials/basics/#Custom-Renderable-Objects-1","page":"AutoViz Basics","title":"Custom Renderable Objects","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"using Colors\n\nstruct MyRenderableCircle\n    pos::VecE2\n    radius::Float64\n    color::Colorant\nend\n\nfunction AutoViz.add_renderable!(rendermodel::RenderModel, circle::MyRenderableCircle)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"add the desired render instructions to the rendermodel","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"    add_instruction!(\n        rendermodel, AutoViz.render_circle,\n        (circle.pos.x, circle.pos.y, circle.radius, circle.color),\n        coordinate_system=:scene\n    )\n    return rendermodel\nend\n\ncircles = [MyRenderableCircle(VecE2(4i,3.0*(1+sin(i/4))), .5+rand(), rand(RGB)) for i in 1:20]\nsnapshot = render([roadway, circles..., scene], canvas_height=120)\n#md\nwrite(\"custom_circles.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: custom circles)","category":"page"},{"location":"tutorials/basics/#Simulation-and-Animations-1","page":"AutoViz Basics","title":"Simulation and Animations","text":"","category":"section"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"We can simulate the scenario over time and visualize the results using Reel (based on ffmpeg).","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"using Reel\n\ntimestep = 0.1\nnticks = 50\n\nmodels = Dict((i => Tim2DDriver(timestep) for i in 1:3))  # car models\nmodels[42] = Tim2DDriver(timestep)  # TODO: better pedestrian model\n\nscenes = simulate(scene, roadway, models, nticks, timestep)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    render([roadway, scenes[i]], canvas_height=120)\nend\n\nwrite(\"roadway_animated.gif\", animation)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"(Image: animated roadway)","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"Alternatively, the scene can also be visualized interactively using Interact","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"Another common visualization package is Reactive.","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"","category":"page"},{"location":"tutorials/basics/#","page":"AutoViz Basics","title":"AutoViz Basics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#About-1","page":"Home","title":"About","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"AutoViz is a package for visualizing simple traffic scenarios using Cairo. It is primarily designed to provide rendering support for AutomotiveDrivingModels.jl. The framework currently supports building blocks such as roadways, vehicles and pedestrians and can be easily extended.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The tutorials provide a sequence of simple examples showcasing some of the main features of the AutoViz package, such as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"basic rendering of vehicles and roadways\ndemo of the available camera behaviors\nadding additional information through overlays","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nAll AutoViz tutorials are available as Jupyter notebooks by clicking on the badge at the beginning of the notebook!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Manual section lists more details of the provided functions, which can also be accessed through the Julia REPL by typing ?function_name.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Installation instructions can be found in the repository README.","category":"page"}]
}
